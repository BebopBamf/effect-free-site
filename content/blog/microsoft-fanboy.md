+++
title = "Microsoft Fanboy"
date = 2021-02-10

[taxonomies]
categories = ["Development"]
tags = ["F#", "enterprise web development", "backend web development", "REST APIs", "Functional Programming"]
+++

I have tried developing a web api in F#, progress is going great but it is very janky and I have mixed feelings.

<!-- more -->

# F# for web development and my first 'enterprise' language

So for those who don't know me I would consider myself an intermediate or experienced programmer. Having used languages such as Haskell, Java, C#,
Python, C++, GoLang and others. I have made many restful api's but never in languages that people would consider 'Enterprise'. I mainly use Rust
and Actix web because I always found it was relatively easy to use while being blazing fast, super safe and also fun. Except as an emerging language
I found that some of it's integration with things like Docker had a lot to be desired. Then you would always end up fighting a type checker or something
and it would be more of a frustrating experience to develop with. Also Rust seems so little known outside of major 'Rustacians' that it doesn't seem like
a good selling point when you tell people, 'Oh yeah, I mainly write in rust'. So for this year I really wanted to learn some more 'enterprise' and well known
languages. I had heard lots and lots of good things about the dotnet toolstack and F# and as someone who also considers themselves a more functional programmer
I really really wanted to try it. Among the other enterprise level web programming languages, I also plan on trying elixir, GoLang and Clojure. One of my
formitive experiences in programming was developing an API in golang, but this was long before I understood memory safety, the difference between the stack 
and the heap, and the general structure of an API so my API was a mess and put me off golang for quite a while. F# was definately my first choice in trying
a more common language because it is one of the few languages along with Clojure that I would consider 'enterprise', also I learn't to program in C# and ever 
since moving to Linux as my main OS had been missing the dotnet toolstack. Now with dotnet core 5 and eagerness I was ready to re-enter my roots as a dotnet
developer and it was even more fun then I had thought.

## The good

F# as a language is one of my favourite languages to use so far, it is a nice bridge between being as functional as Haskell, but not being too restrictive that
it hampers development speeds. It's entire language structure revolves around monads, and function composition, which are some of my favourite idea's in programming.
The tools were a pleasure to work with and all the boilerplate code was autogenerated. This was definately a far cry from Rust which had a lot of boiler plate code
that needed to be written before a web server was up and running. It supports async operations which for now I am too afraid to use, and being a functional language
I am sure there are a plethora of multithreading options. A nice bonus too is having the support of being a 'enterprise' language. Something you feel comfortable
using because you know that production code runs using the tool stack. Running on aspnet using Giraffe, F# was so nice to have interoperability with C#. The type
system felt very comfortable and was very fun to play around with.


## Paket the F# package manager

Paket by itself was super nice to work with, I really enjoyed it. Back when I first started programming, I almost never used package managers, using instead the
integrated packages autogenerated by libraries. This all changed in highschool when I started using pip with python. Then going to Cpp, really highlighted how nice
a really easy to use package manager is. Using rust now, for me having a really good package manager, or just the ability to quickly add libraries and swap them out
is a super important and integral part of my web development experience. It is something I rely on when learning a new language and Paket by itself didn't disappoint.

## The horror stories

Now there are a couple of things that I still am not sold on about writing web api's in F#. When I first started I was super old fashioned and would only setup databases
the traditional way, instead of containerising. I would avoid Docker at all costs. When I kept hearing about how good Docker was I started using it and I plan on only
using Docker for databases from now on for automation purposes. There was a slight snag though when I tried integrating an actix_web api I had written in rust with
Docker. I use postgres for all my databases and was using a new database driver written in pure rust (sqlx) to connect to postgres. The problem was that using docker-compose
would compile the web api before starting the database. Sqlx needed the database to be up and running at compile time in order to perform type checking of data types at 
compile time. This is a super nice feature but makes containerising a nightmere, and I asked around everywhere and nobody I talked to had ever encountered that problem before
because type checking database types at compile time was such a niche thing for university hobbiests. This pushed me to consider using other languages and extending myself,
but since then sqlx has added support for offline database type checking using json files. Now there are database ORM's for dotnet, but when using F# because of it's extensive
type system seemed to recommend using F# specific database ORM's instead for added type benefits. These also checked database types at compile time so undergo the same problem
but they support offline databases just like rust. It does seem to be alot more work then rust does and the documentation is very vague from what I have read so I am not keen
on that. Now might be a good time to mention all my complaints are going to be database related sadly. There seems to be lots of database libraries for F# but really only
one had support for the database I use Postgres where all the otherones used microsoft databases. I struggled so much to install this database driver, all morning was spent
trying to install it. So I installed the database driver using Paket, but the library didn't work, I ended up trying multiple things and breaking the project. That is when
I found a little snippet of the website saying you needed to link a certain binary to the application, and doing some digging found a file paket.references. I created a new
project that was a replica of the older project and added the library name which was SQLProvider to the project paket.references file. This ended up working, but I felt like
the documentation could have included more information about this and am still not sure if I had installed it correctly. My second thing that annoyed me was for a rest api
it wasn't clear if there was an easy way to return the changed values after an insert or an update query. This is standard rest stuff, so it would've been nice to have a clear
way, I couldn't find any browswing throught the guide. The last thing that probably annoyed me the most about the database library was how it handled errors. Once inserting new
values into the database, you call `ctx.SubmitUpdates` which is a function that returns a unit type. For the non-functional programmers, a unit type is the equivalent of 
a function returning void in C#, Java or Cpp. This to me points to the library using impure functions, I would have liked to see a monad here, or a Result type such as in rust.
I like it when database libraries return Result, because then you can create a set of Http errors, and map each Result Err into a Http Err, for example if a Product already exists
and you try creating a product with the same id, then you can map the database error to a http error an error response in your rest api. This doesn't seem possible with F#
and which for a functional programming language dissapointed me. So maybe I will continue the project in F#, or maybe move to Elixir or back to good old Rust.
